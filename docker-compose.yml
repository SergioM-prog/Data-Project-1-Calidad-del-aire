services:
  db:
    image: postgres:17-alpine
    env_file:
      - .env
    ports:
      - "5431:5432"
    restart: unless-stopped

  # === INGESTA POR CIUDAD ===
  # Cada ciudad corre en su propio contenedor, usando la misma imagen
  # pero con diferente variable CITY. Esto permite arrancar/parar cada
  # ciudad de forma independiente: docker compose stop ingestion-valencia

  ingestion-valencia:
    build: ./ingestion
    image: aq_ingestion:latest
    pull_policy: build  # Fuerza a construir la imagen localmente en lugar de intentar descargarla
    environment:
      - PYTHONUNBUFFERED=1
      - CITY=valencia       # Es una variable de entorno que leerá el orquestador main.py y ejecutará sólo la fun. de ingesta de esa ciudad
    env_file: .env
    depends_on:
      backend:
        condition: service_healthy  # Espera a que el backend pase el healthcheck

  # ingestion-madrid:
  #   image: aq_ingestion:latest
  #   environment:
  #     - PYTHONUNBUFFERED=1
  #     - CITY=madrid
  #   env_file: .env
  #   depends_on:
  #     - backend

# 3. TRANSFORMACIONES DBT (Transformaciones de datos - Cada 5 minutos)

  dbt:
    image: ghcr.io/dbt-labs/dbt-postgres:1.8.2

    # Sobrescribimos el punto de entrada para poder usar comandos de shell (sh). La imagen de dbt viene configurada para ejecutar el comando dbt automáticamente al arrancar
    # Con entry point Docker ignora por completo cualquier configuración interna de la imagen original y lanza directamente la cadena de comandos
    # Incorporamos un bucle para que se generen las transformaciones cada 5 minutos, misma frecuencia con la que la app llama a la api

    entrypoint: /bin/sh -c "sleep 20; dbt deps; while true; do dbt run && dbt docs generate --static; echo 'Transformación completada. Esperando 5 minutos...'; sleep 300; done"
    environment:
      - DBT_PROFILES_DIR=/usr/app/air_quality_dbt
    volumes:
      - ./dbt/air_quality_dbt:/usr/app/air_quality_dbt
    working_dir: /usr/app/air_quality_dbt
    env_file: .env
    depends_on:
      - db

  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin # Contraseña inicial
    env_file: .env
    volumes:
      - ./grafana/provisioning/datasources:/etc/grafana/provisioning/datasources
      - ./grafana/provisioning/dashboards:/etc/grafana/provisioning/dashboards
      - ./grafana/dashboards:/var/lib/grafana/dashboards
      - grafana_data:/var/lib/grafana
    depends_on:
      - db
    restart: unless-stopped

  # 4. BACKEND API (Servidor que lee datos - Puerto 8000)
  backend:
    build: ./backend
    pull_policy: build  # Fuerza a construir la imagen localmente en lugar de intentar descargarla
    container_name: air-quality-api
    ports:
      - "8000:8000" # Acceso: http://localhost:8000/docs
    env_file: .env
    volumes:
      - ./historical:/app/historical:ro  # Datos históricos (solo lectura)
    depends_on:
      - db
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "python", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8000/health', timeout=5)"]
      interval: 10s
      timeout: 10s
      retries: 12
      start_period: 60s  # Tiempo de gracia para cargar datos históricos

  # # 5. FRONTEND USUARIO (Dash/Plotly - Puerto 8050)
  # frontend:
  #   build: ./frontend
  #   container_name: air-quality-frontend
  #   ports:
  #     - "8050:8050" # Acceso: http://localhost:8050
  #   environment:
  #     # IMPORTANTE: Aquí usamos el nombre del servicio 'backend' dentro de la red Docker
  #     - API_URL=http://backend:8000
  #   depends_on:
  #     - backend
  #   restart: unless-stopped


volumes:
  grafana_data: